// This module contains all relevant functions for
// querying data from the Prometheus database.

import moment from "moment";

const api = "http://localhost:9090/api/v1/query?";

function formatQuery(query, range, offset) {
    // WARNING: converts to scalar, which strips label names
    query = query.replaceAll("{r}", range).replaceAll("{o}", offset);
    return `${api}query=scalar(${query})`;
}

export function oldestSample() {
    // Returns the time of the oldest sample in the database.
    // Note: the resolution on this query may need to be shortened
    // if Prometheus has been running for less than a day.
    return (
        fetch(formatQuery("min_over_time(timestamp(up)[5y:1d])"))
            .then(res => res.json())
            .then(res => moment.unix(res.data.result[1]))
    );
}

export function fetchLive() {
    // This query currently gets all metrics from the
    // "hvac" job, where the `__name__` attribute
    // does not match regex `(scrape).*`, since
    // those are auto-generated by prometheus.
    return (
        fetch(api + 'query={job="hvac",__name__!~"(scrape).*"}')
            .then(res => res.json())
            .then(res => extractLiveMetrics(res.data.result))
    );
}


function extractLiveMetrics(result) {
    // Extracts metrics with label names for the LiveView
    console.log(result);
    let metrics = result.map(metric => {
        return ({'name': metric['metric']['__name__'],
                 'value': metric['value'][1]}
        );
    });

    // From our response, check the "up" metric, which tells
    // us if Prometheus is able to actively read from the sensors.
    let up_index;
    for (let i = 0; i < metrics.length; i++) {
        if (metrics[i]['name'] === "up") {
            up_index = i;
            break;
        }
    }

    if (metrics[up_index]['value'] !== "1") {
        throw new Error("Prometheus is unable to read sensors. Is the Flask app running?");
    }

    // we don't want to display this metric to the user
    delete metrics[up_index];
    return metrics;
}

function getRangeOffset(startDate, endDate) {
    console.log("startDate: " + startDate.toString());
    console.log("endDate: " + endDate.toString());

    let range = endDate.diff(startDate, 'minutes');
    let offset = moment().diff(endDate, 'minutes');

    console.log(`range: ${range.toString()} minutes`);
    console.log(`offset: ${offset.toString()} minutes`);

    if (range <= 0) {
        throw new Error(`startDate must be earlier than endDate (range: ${range} minutes)`);
    }
    if (offset < 0) {
        throw new Error(`Cannot query the future (offset: ${offset} minutes)`);
    }

    return {
        'range': `${range}m`,
        'offset': offset > 0 ? ` offset ${offset}m` : "",
    }
}

async function extract(response) {
    response = await response.json();

    if (response.status === "error") {
        // throw new Error(response.error);
        console.error(response.error);
        return null;
    }

    try {
        return response.data.result[1];
    } catch {
        // throw new Error("...");
        console.error("Unable to extract `data.result[1]` from: ", response);
        return null;
    }
}

function fetchQuery(query, range, offset) {
    console.log("sending query: " + formatQuery(query, range, offset));
    return (
        fetch(formatQuery(query, range, offset))
            .then(res => {
                res = extract(res);
                console.log({
                    query: query,
                    result: res
                });
                return res;
            })
    );
}

function onOffCycleCount(range, offset) {
    return fetchQuery("changes(is_on[{r}]{o}) / 2", range, offset);
}

function avgTemperatureDelta(range, offset) {
    return fetchQuery(
        "avg_over_time(((incoming_air - outgoing_air) and (is_on == 1))[{r}:15s]{o})",
        range, offset
    );
}

function avgOnCycleDuration(range, offset) {
    return fetchQuery(
        "(sum_over_time(is_on[{r}:15s]{o}) / (changes(is_on[{r}:15s]{o}) / 2)) * 15",
        range, offset
    );
}

export function fetchRangeAggregates(startDate, endDate) {
    const {range, offset} = getRangeOffset(startDate, endDate);

    // TODO: implement conditional results.
    //       ex: get average daily on/off cycle count
    //       only if range > 1d, and cut off results from
    //       partial days.

    return ({
        "On/Off Cycle Count": onOffCycleCount(range, offset),
        "Average Delta-T": avgTemperatureDelta(range, offset),
        "Average On-Cycle Duration": avgOnCycleDuration(range, offset),
    });
}
