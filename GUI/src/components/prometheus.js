// This module contains all relevant functions for
// querying data from the Prometheus database.

import moment from "moment";

const api = "http://localhost:9090/api/v1/query?";

class Query {
    constructor(name, template, colSettings) {
        this.name = name;
        this.template = template;
        this.colSettings = colSettings;
        this.data = null;
    }

    execute(range, offset) {
        const query = this.template.replaceAll("{r}", `${range}m`)
            .replaceAll("{o}", offset > 0 ? ` offset ${offset}m` : "");

        this.data = fetch(`${api}query=(${query})`)
            .then(res => this.extract(res));
    }

    async extract(response) {
        response = await response.json();

        if (response.status === "error") {
            console.error(response);
            throw new Error(response.error);
        }

        try {
            const data = response.data.result[0];
            return response.data.resultType === "matrix" ? data.values : [data.value];
        } catch {
            console.error("Unable to extract `data.result[0]` from: ", response);
            // TODO: catch this error somewhere else
            throw new Error("Unable to extract data from Prometheus's response");
        }
    }
}

export function oldestSample() {
    // Returns the time of the oldest sample in the database.
    // Note: the resolution on this query may need to be shortened
    // if Prometheus has been running for less than a day.
    const q = new Query("", "min_over_time(timestamp(up)[5y:1d])");
    q.execute();
    return q.data;
}

export function fetchLive() {
    // This query currently gets all metrics from the
    // "hvac" job, where the `__name__` attribute
    // does not match regex `(scrape).*`, since
    // those are auto-generated by prometheus.
    return (
        fetch(api + 'query={job="hvac",__name__!~"(scrape).*"}')
            .then(res => res.json())
            .then(res => extractLiveMetrics(res.data.result))
    );
}

function extractLiveMetrics(result) {
    // Extracts metrics with label names for the LiveView
    console.log(result);
    let metrics = result.map(metric => {
        return ({'name': metric['metric']['__name__'],
                 'value': metric['value'][1]}
        );
    });

    // From our response, check the "up" metric, which tells
    // us if Prometheus is able to actively read from the sensors.
    let up_index;
    for (let i = 0; i < metrics.length; i++) {
        if (metrics[i]['name'] === "up") {
            up_index = i;
            break;
        }
    }

    if (metrics[up_index]['value'] !== "1") {
        throw new Error("Prometheus is unable to read sensors. Is the Flask app running?");
    }

    // we don't want to display this metric to the user
    delete metrics[up_index];
    return metrics;
}

export function getRangeOffset(startDate, endDate) {
    return {
        range: endDate.diff(startDate, 'minutes'),
        offset: moment().diff(endDate, 'minutes')
    };
}

export const Queries = [
    new Query(
        "On/Off Cycle Count",
        "changes(is_on[{r}]{o}) / 2",
        {
            width: 160,
        }
    ),
    new Query(
        "Average Delta-T",
        "avg_over_time(((incoming_air - outgoing_air) and (is_on == 1))[{r}:15s]{o})",
        {
            width: 135,
            valueFormatter: ({value}) => `${value.toFixed(2)} \xB0C`
        }
    ),
    new Query(
        "Average On-Cycle Duration",
        "(sum_over_time(is_on[{r}:15s]{o}) / (changes(is_on[{r}:15s]{o}) / 2)) * 15",
        {
            width: 205,
            valueFormatter: ({value}) => {
                let d = moment.duration(value, 'seconds');
                return (
                    (d.asMinutes() < 1 ? "" : `${d.minutes()} minutes, `)
                    + `${d.seconds()} seconds`
                );
            }
        }
    )
]

export async function rowsFromQueries(range, offset) {
    const data = await Promise.all(
        Queries.map(
            async (q) => {
                q.execute(range, offset);
                return [q.name, await q.data];
            })
    )
    return data[0][1].map(
        ([ts,_], i) => ({
            id: i, Timestamp: ts,
            ...Object.fromEntries(
                data.map(
                    ([name, values]) => [name, Number(values[i][1])]
                )
            )
        })
    );
}