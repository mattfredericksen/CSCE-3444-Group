// This module contains all relevant functions for
// querying data from the Prometheus database.

import moment from "moment";

// address prefix at which Prometheus is running
const api = "http://dodc:9090/api/v1/query?";


/**
 * Convert a moment duration into a Prometheus-compatible duration string.
 * @param {moment.Duration} dur
 * @returns {string}
 */
function durationString(dur) {
    return dur ? `${Math.floor(dur.asDays())}d${dur.hours()}h${dur.minutes()}m` : "";
}


/**
 * A class representing Prometheus queries and facilitating
 * query response data extraction.
 */
class Query {
    /**
     * @param {string} name is a human-readable name describing
     *     the purpose of the query. It is also used as the column
     *     header when displayed by `HvacDataGrid`.
     *
     * @param {string} template is the query text which will
     *     be sent to Prometheus. It may contain tags {r} and {o},
     *     which will be replaced by `range` and `offset` arguments
     *     as passed to `Query.execute`.
     *
     * @param {Object=} colSettings contains settings that will
     *     be applied to this query's column when loaded by `HvacDataGrid`.
     */
    constructor(name, template, colSettings={}) {
        this.name = name;
        this.template = template;
        this.colSettings = colSettings;
    }

    /**
     * Executes the query and returns a Promise
     * containing the extracted result array.
     *
     * @param {moment.Duration} range, difference between start and end dates
     * @param {moment.Duration} offset, difference from now to end date
     * @param {moment.Duration} duration, length of time over which to repeat the query
     * @param {moment.Duration} resolution, how often to repeat the query within `duration`
     * @returns {Promise<Array[]>}
     */
    async execute(range, offset, duration, resolution) {
        const [rangeStr, offsetStr, durationStr, resolutionStr] = (
            [...arguments].map(durationString)
        );

        let query = this.template.replaceAll("{r}", rangeStr);

        if (duration && resolution) {
            query = query.replaceAll("{o}", "");
            query = `(${query})[${durationStr}:${resolutionStr}]{o}`;
        }

        query = query.replaceAll("{o}",
            offset && offset.asMinutes() > 1 ? ` offset ${offsetStr}` : "");

        return this.extract(await fetch(`${api}query=(${query})`), offset);
    }

    /**
     * Takes Prometheus's HTTP response and extracts
     * the data result arrays.
     *
     * @param response {Response}
     * @param offset {moment.Duration}
     * @returns {Promise<Array[]>}
     * @throws when response status is "error"
     *     or when response data is empty.
     */
    async extract(response, offset) {
        const res = await response.json();

        if (res.status === "error") {
            console.error(res);
            throw new Error(`Query failed: ${res.error}`);
        }

        console.log("Query Response Data:\n",
            {Query: response.url, ...res.data.result});

        try {
            const data = res.data.result[0];
            // The result may contain a single Array or an
            // Array of Arrays. This logic ensures the dimensions
            // of the return value are always the same.
            if (res.data.resultType === "matrix") return data.values;
            // manually correct timestamp values stripped during aggregation
            if (offset) data.value[0] -= offset.asSeconds();
            return [data.value];
        } catch {
            console.error("Unable to extract `data.result[0]` from: ", res);
            if (res.data.result.length === 0) {
                throw new Error("Prometheus has no data for this time range");
            } else {
                throw new Error("Unable to extract data from Prometheus's response");
            }
        }
    }
}


/**
 * Returns the time of the oldest sample in the database.
 * @returns {Promise<Moment>}
 */
export async function oldestSample() {
    // The resolution on this query may need to be shortened
    // if Prometheus has been running for less than a day.
    const q = new Query("", "min_over_time(timestamp(up)[5y:1d])");
    return moment.unix((await q.execute())[0][1]);
}


export function fetchLive() {
    // This query currently gets all metrics from the
    // "hvac" job, where the `__name__` attribute
    // does not match regex `(scrape).*`, since
    // those are auto-generated by prometheus.
    return (
        fetch(api + 'query={job="hvac",__name__!~"(scrape).*"}')
            .then(res => res.json())
            .then(extractLiveMetrics)
    );
}


function extractLiveMetrics({data: {result}}) {
    // Extracts metrics with label names for the LiveView
    console.log(result);
    let metrics = result.map(metric => {
        return ({'name': metric['metric']['__name__'],
                 'value': metric['value'][1]}
        );
    });

    // From our response, check the "up" metric, which tells
    // us if Prometheus is able to actively read from the sensors.
    let up_index;
    for (let i = 0; i < metrics.length; i++) {
        if (metrics[i]['name'] === "up") {
            up_index = i;
            break;
        }
    }

    if (metrics[up_index]['value'] !== "1") {
        throw new Error("Prometheus is unable to read sensors. Is the Flask app running?");
    }

    // we don't want to display this metric to the user
    delete metrics[up_index];
    return metrics;
}


/**
 * @type {Query[]}
 * An array of Query instances which will be executed
 * when loading `HvacDataGrid`. Their order in this
 * Array determines the column order of the DataGrid.
 *
 * colSettings:
 * `width` is the column width for this query.
 * `valueFormatter` is a function which will be
 *     applied before displaying the data.
 */
export const Queries = [
    new Query(
        "On/Off Cycle Count",
        "changes(is_on[{r}]{o}) / 2",
        {width: 160}
    ),
    new Query(
        "Max Delta-T",
        "max_over_time((incoming_air - outgoing_air)[{r}:15s] {o})",
        {
            width: 115,
            valueFormatter: ({value}) => (
                isNaN(value) ? value : `${value.toFixed(2)} \xB0C`
            )
        }
    ),
    new Query(
        "Average On-Cycle Duration",
        "(sum_over_time(is_on[{r}:15s]{o}) / (changes(is_on[{r}:15s]{o}) / 2)) * 15",
        {
            width: 205,
            valueFormatter: ({value}) => {
                if (isNaN(value)) return value;
                const d = moment.duration(value, 'seconds');
                const [m, s] = [d.minutes(), d.seconds()];
                return (
                    (m < 1 ? "" : `${m} minute${m !== 1 ? "s" : ""}, `)
                    + `${s} second${s !== 1 ? "s" : ""}`
                );
            }
        }
    )
]


/**
 * Generates a list of row objects for loading into `HvacDataGrid`.
 *
 * Parameters follow the signature `Query.execute`.
 * @returns {Promise<Object[]>}
 */
export async function rowsFromQueries(range, offset, duration, resolution) {

    // create a sorted array of unique timestamps
    let timestamps = new Set();

    // get an array of pairs, first item is query name,
    // second item is array containing query results
    const data = await Promise.all(
        Queries.map(async (q) => ([
            q.name,
            Object.fromEntries(
                (await q.execute(range, offset, duration, resolution)).map(
                    // quick fix: when range mode is off, timestamp resolution
                    // increases to milliseconds, giving unique values to
                    // metrics collected at the same time. There's probably
                    // a better way to solve this by checking whether
                    // range query mode is enabled.
                    ([ts, value]) => {
                        ts = Math.round(ts);
                        timestamps.add(ts);
                        return [ts, Number(value)];
                    }
                )
            )
        ]))
    )
    timestamps = [...timestamps].sort();
    console.log("timestamps: ", timestamps);

    // For every timestamp, create a row object
    // containing that timestamp and the result
    // of each query at the same timestamp. Results
    // with missing timestamps are evaluated as NaN.
    return timestamps.map(
        (ts, i) => ({
            id: i, Timestamp: ts,
            ...Object.fromEntries(
                data.map(([name, datum]) => {
                    const value = datum[ts];
                    // NaN must be explicitly converted to "NaN"
                    // to avoid DataGrid errors.
                    return [name, isNaN(value) ? "NaN": value];
                })
            )
        })
    );
}